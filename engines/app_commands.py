"""
Internal CLI command handler for the application.
Processes commands starting with '//' to manage settings, history, and app state.
"""
import sys
import os
import shutil
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import re
import json
from colorama import Fore, init, Style
from engines.config import update_setting, get_setting
from engines.utilities import pick_history
from engines.utilities import pick_profile
from engines.utilities import pick_user_profile, render_historical_message # Import render_historical_message
from engines.memory_v2 import memory_manager # Import memory_manager

# Initialize colorama
init(autoreset=True)


# Path to conversation history files
HISTORY_PATH = "history/"

class RestartRequested(Exception):
    """Exception raised to signal the main loop to restart the application."""
    pass

def app_commands(ops: str):
    """
    Dispatcher for internal operational commands.

    Args:
        ops (str): The raw command input (e.g., '//help').

    Returns:
        bool: True if the command was recognized and handled, False otherwise.
    """

    def _help():
        """Lists all available commands."""
        print(Fore.YELLOW + "[AVAILABLE COMMANDS]")
        for cmd in cmds.keys():
            print(Fore.CYAN + f"  {cmd}")

    def _exit():
        """Exits the application."""
        print(Fore.YELLOW + "[SYSTEM] Exiting application...")
        sys.exit(0)

    def _show_settings():
        """Displays current system settings from settings.json."""
        from engines.config import load_settings
        settings = load_settings()
        print(Fore.YELLOW + "[CURRENT SETTINGS]")
        for key, value in settings.items():
            # Color-code booleans for readability
            val_str = Fore.GREEN + str(value) if isinstance(value, bool) and value else \
                      Fore.RED + str(value) if isinstance(value, bool) else \
                      Fore.WHITE + str(value)
            print(Fore.CYAN + f"  {key}: " + val_str)

    def _toggle_narration():
        is_enabled = get_setting("speak_narration", False)
        print(Fore.GREEN + "[SYSTEM] Narration enabled." if not is_enabled else Fore.RED + "[SYSTEM] Narration disabled.")
        update_setting("speak_narration", not is_enabled)

    def _toggle_speak():
        is_enabled = get_setting("tts_enabled", True)
        print(Fore.GREEN + "[SYSTEM] Text-to-Speech enabled." if not is_enabled else Fore.RED + "[SYSTEM] Text-to-Speech disabled.")
        update_setting("tts_enabled", not is_enabled)

    def _toggle_command():
        is_enabled = get_setting("execute_command", False)
        print(Fore.GREEN + "[SYSTEM] Command execution enabled." if not is_enabled else Fore.RED + "[SYSTEM] Command execution disabled.")
        update_setting("execute_command", not is_enabled)

    def _reset():
        """Wipes a specific history file chosen by the user."""
        print(Fore.YELLOW + "[SYSTEM] Conversation history reset.")
        history_path = pick_history()
        if history_path:
            # Extract profile name from filename (e.g., 'Glitch_history.json' -> 'Glitch')
            profile_name = os.path.basename(history_path).replace("_history.json", "")
            memory_manager.save_history(profile_name, [])
            print(Fore.GREEN + "[SYSTEM] History cleared.")
        else:
            print(Fore.RED + "[SYSTEM] No history selected.")

    def _reset_all():
        """Wipes ALL history files in the history directory."""
        confirm = input(Fore.RED + "Are you sure you want to reset ALL history files? (y/n): ").strip().lower()
        if confirm == 'y':
            from engines.memory_v2 import memory_manager
            for filename in os.listdir(HISTORY_PATH):
                if filename.endswith(".json"):
                    profile_name = filename.replace("_history.json", "")
                    memory_manager.save_history(profile_name, [])
            print(Fore.GREEN + "[SYSTEM] All history files have been wiped.")
        else:
            print(Fore.YELLOW + "[SYSTEM] Reset cancelled.")

    def _reset_rel():
        """Resets the relationship score of a chosen profile to zero."""
        profile_path = pick_profile()
        if profile_path:
            with open(profile_path, "r+", encoding="UTF-8") as f:
                profile_data = json.load(f)
                profile_data["relationship_score"] = 0
                f.seek(0)
                json.dump(profile_data, f, indent=4)
                f.truncate()
            print(Fore.GREEN + "[SYSTEM] Relationship score reset to 0.")
        else:
            print(Fore.RED + "[SYSTEM] No profile selected.")

    # Note: Still somewhat buggy.
    def _restart():
        """Signals the main loop to restart."""
        print(Fore.YELLOW + "[SYSTEM] Restarting application...")
        raise RestartRequested()

    def _clear():
        """Clears the terminal screen."""
        os.system('cls' if os.name == 'nt' else 'clear')
        print(Fore.YELLOW + "[SYSTEM] Screen cleared.")

    def _change_character():
        """Restarts the app to allow picking a new character."""
        print(Fore.YELLOW + "[SYSTEM] Changing character...")
        raise RestartRequested()

    def _change_user_profile():
        """Prompts for a new user profile and restarts."""
        print(Fore.YELLOW + "[SYSTEM] Changing user profile.")
        new_profile_path = pick_user_profile()
        if new_profile_path:
            new_profile_name = os.path.basename(new_profile_path)
            update_setting("current_user_profile", new_profile_name)
            print(Fore.GREEN + f"[SYSTEM] User profile changed to {new_profile_name}. Restarting...")
            raise RestartRequested()
        else:
            print(Fore.RED + "[SYSTEM] No user profile selected.")

    def _toggle_clear_on_start():
        is_enabled = get_setting("clear_at_start", True)
        print(Fore.GREEN + "[SYSTEM] Console will now clear at startup." if not is_enabled else Fore.RED + "[SYSTEM] Console will no longer clear at startup.")
        update_setting("clear_at_start", not is_enabled)

    def _history():
        """Displays the last 15 messages from the current character's history."""
        current_profile_setting = get_setting("current_character_profile")
        if not current_profile_setting:
            print(Fore.RED + "[SYSTEM] No character profile active. Cannot display history." + Style.RESET_ALL)
            return

        # Extract character name from the profile path stored in settings
        profile_name = os.path.basename(current_profile_setting).replace(".json", "")

        # Try to get display names
        ch_name = "Assistant"
        user_name = "User"

        try:
            with open(os.path.join("profiles", current_profile_setting), "r", encoding="UTF-8") as f:
                ch_name = json.load(f).get("name", "Assistant")

            user_profile_filename = get_setting("current_user_profile")
            if user_profile_filename:
                with open(os.path.join("user_profiles", user_profile_filename), "r", encoding="UTF-8") as f:
                    user_name = json.load(f).get("name", "User")
        except:
            pass

        recap_messages = memory_manager.load_history(profile_name, limit=15)
        if recap_messages:
            print(Fore.WHITE + Style.DIM + "\n=== Past Conversation ===" + Style.RESET_ALL)
            for msg in recap_messages:
                render_historical_message(msg.get("role"), msg.get("content", ""), user_name=user_name, char_name=ch_name)
            print(Fore.WHITE + Style.DIM + "=========================" + Style.RESET_ALL)
        else:
            print(Fore.YELLOW + "[SYSTEM] No history found for the current profile." + Style.RESET_ALL)

    def _toggle_recap_on_start():
        is_enabled = get_setting("auto_recap_on_start", True)
        print(Fore.GREEN + "[SYSTEM] Auto recap at startup is now enabled." if not is_enabled else Fore.RED + "[SYSTEM] Auto recap at startup is now disabled.")
        update_setting("auto_recap_on_start", not is_enabled)

    def _clear_cache():
        """Clears the TTS cache directory."""
        cache_dir = "tts_cache"
        if os.path.exists(cache_dir):
            try:
                shutil.rmtree(cache_dir)
                print(Fore.GREEN + "[SYSTEM] TTS cache cleared.")
            except Exception as e:
                print(Fore.RED + f"[SYSTEM] Failed to clear TTS cache: {e}")
        else:
            print(Fore.YELLOW + "[SYSTEM] No TTS cache found to clear.")

    # Mapping of command strings to their respective functions
    cmds = {
        "//exit": _exit,
        "//quit": _exit,
        "//help": _help,
        "//clear": _clear,
        "//change_character": _change_character,
        "//change_user_profile": _change_user_profile,
        "//reset": _reset,
        "//reset_all": _reset_all,
        "//reset_rel": _reset_rel,
        "//restart": _restart,
        "//toggle_speak": _toggle_speak,
        "//toggle_narration": _toggle_narration,
        "//toggle_command": _toggle_command,
        "//toggle_clear_at_start": _toggle_clear_on_start,
        "//toggle_recap_on_start": _toggle_recap_on_start,
        "//show_settings": _show_settings,
        "//history": _history,
        "//recap": _history,
    }

    pattern = re.match(r'^/+', ops.strip().lower())
    if pattern:
        ops = "//" + ops[pattern.end():]
    action = cmds.get(ops.lower())
    if action:
        action()
        return True
    return False
